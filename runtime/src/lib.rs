#![no_std]

//! Runtime support types for code generated by the Idol compiler.
//!
//! Most uses of Idol don't need to pull this crate in, but generated servers
//! often do.

use userlib::{FromPrimitive, TaskId, RecvMessage, sys_recv, sys_reply};

/// Trait for a server to implement if it wants to be compatible with the
/// generated dispatch loops that also route notifications.
///
/// The compiler does not generate an impl for this trait, you need to customize
/// it for your server.
pub trait NotificationHandler {
    /// Produces the notification mask that should be used on any calls to RECV.
    ///
    /// If an implementation returns 0, no notifications will be accepted.
    fn current_notification_mask(&self) -> u32;

    /// Entry point for processing notifications.
    ///
    /// The dispatch loop calls this routine when RECV has returned
    /// notifications instead of a message. The notification bits that were
    /// observed to be set (and atomically cleared) are passed as `bits`.
    fn handle_notification(&mut self, bits: u32);
}

/// Trait implemented by enums that model the operations in an IPC interface.
///
/// Normally the compiler will generate both the enum and the impl of this trait
/// for it.
pub trait ServerOp: FromPrimitive + Copy {
    /// Size of response buffer required for this message, in bytes.
    fn max_reply_size(&self) -> usize;
}

/// Trait implemented by things that serve.
///
/// The generated compiler support code will provide a blanket dispatch impl for
/// this trait, you do not normally need to implement it yourself.
pub trait Server<Op: ServerOp> {
    /// Source passed to RECV to control open vs closed receive.
    fn recv_source(&self) -> Option<TaskId>;
    /// Called by the dispatch loop if the server requested a closed receive,
    /// but the task it named has died. Typically this means the server needs to
    /// update its records.
    fn closed_recv_fail(&mut self);

    /// Handles a message.
    ///
    /// For convenience, this returns a `Result`. If it returns `Err(x)`, then
    /// `x` will be sent to the sender as the response code, with a zero-byte
    /// message. If it returns `Ok(())`, it's asking the dispatch loop to
    /// consider the message handled, and the server code is responsible for
    /// calling `sys_reply` at an appropriate time.
    fn handle(
        &mut self,
        op: Op,
        incoming: &[u8],
        rm: &RecvMessage,
    ) -> Result<(), u32>;
}

/// Generic server dispatch routine for cases where notifications are not
/// required.
///
/// `buffer` is scratch space for incoming messages. It must be large enough to
/// accommodate any message in the IPC interface implemented by the server `S`.
/// (This would be an array sized by an associated constant, but Rust currently
/// doesn't let us do that.)
///
/// `server` is a type that implements `Server<Op>`. More specifically, the
/// implementation must be for `(PhantomData<Op>, &mut S)`. This is a bit of a
/// hack that works around overlapping impl rules. The compiler will normally
/// generate that impl for you, based on your impl of an interface-specific
/// generated trait.
///
/// If you need notifications, use `dispatch_n`.
pub fn dispatch<S, Op: ServerOp>(
    buffer: &mut [u8],
    server: &mut S,
)
    where for <'a> (core::marker::PhantomData<Op>, &'a mut S): Server<Op>,
{
    let mut server = (core::marker::PhantomData, server);
    let rm = match sys_recv(buffer, 0, server.recv_source()) {
        Ok(rm) => rm,
        Err(_) => {
            server.closed_recv_fail();
            return;
        },
    };

    let incoming = &buffer[..rm.message_len];

    let op = match Op::from_u32(rm.operation) {
        Some(op) => op,
        None => {
            sys_reply(rm.sender, 1, &[]);
            return;
        }
    };

    if rm.response_capacity < op.max_reply_size() {
        sys_reply(rm.sender, 2, &[]);
        return;
    }

    match server.handle(op, incoming, &rm) {
        Ok(()) => {
            // stub has taken care of it.
        }
        Err(code) => {
            // stub has used the convenience return for data-less errors,
            // we'll do the reply.
            sys_reply(rm.sender, code, &[]);
        }
    }
}

/// Generic server dispatch routine for servers that use notifications.
///
/// `buffer` is scratch space for incoming messages. It must be large enough to
/// accommodate any message in the IPC interface implemented by the server `S`.
/// (This would be an array sized by an associated constant, but Rust currently
/// doesn't let us do that.)
///
/// `server` is a type that implements `Server<Op>`. More specifically, the
/// implementation must be for `(PhantomData<Op>, &mut S)`. This is a bit of a
/// hack that works around overlapping impl rules. The compiler will normally
/// generate that impl for you, based on your impl of an interface-specific
/// generated trait.
///
/// `server` is required to directly impl `NotificationHandler` (i.e. you must
/// write the impl yourself).
///
/// If you don't need notifications, use `dispatch`.
pub fn dispatch_n<S: NotificationHandler, Op: ServerOp>(
    buffer: &mut [u8],
    server: &mut S,
)
    where for <'a> (core::marker::PhantomData<Op>, &'a mut S): Server<Op>,
{
    let mut server = (core::marker::PhantomData, server);
    let mask = server.1.current_notification_mask();
    let rm = match sys_recv(buffer, mask, server.recv_source()) {
        Ok(rm) => rm,
        Err(_) => {
            server.closed_recv_fail();
            return;
        },
    };

    if rm.sender == TaskId::KERNEL {
        server.1.handle_notification(rm.operation);
        return;
    }

    let incoming = &buffer[..rm.message_len];

    let op = match Op::from_u32(rm.operation) {
        Some(op) => op,
        None => {
            sys_reply(rm.sender, 1, &[]);
            return;
        }
    };

    if rm.response_capacity < op.max_reply_size() {
        sys_reply(rm.sender, 2, &[]);
        return;
    }

    match server.handle(op, incoming, &rm) {
        Ok(()) => {
            // stub has taken care of it.
        }
        Err(code) => {
            // stub has used the convenience return for data-less errors,
            // we'll do the reply.
            sys_reply(rm.sender, code, &[]);
        }
    }
}
